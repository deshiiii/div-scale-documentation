<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>divAtScale.src.bipartite_config.src.poibin.poibin API documentation</title>
<meta name="description" content="Created on Tue Mar 29, 2016 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>divAtScale.src.bipartite_config.src.poibin.poibin</code></h1>
</header>
<section id="section-intro">
<p>Created on Tue Mar 29, 2016</p>
<h2 id="module">Module</h2>
<p>poibin - Poisson Binomial Distribution</p>
<h2 id="author">Author</h2>
<p>Mika Straka</p>
<h2 id="description">Description</h2>
<p>Implementation of the Poisson Binomial distribution for the sum of
independent and not identically distributed random variables as described
in the reference [Hong2013]_.</p>
<p>Implemented method:</p>
<pre><code>* &lt;code&gt;pmf&lt;/code&gt;: probability mass function
* &lt;code&gt;cdf&lt;/code&gt;: cumulative distribution function
* &lt;code&gt;pval&lt;/code&gt;: p-value (1 - cdf)
</code></pre>
<h2 id="usage">Usage</h2>
<p>Be <code>p</code> a list or
NumPy array of success probabilities for <code>n</code>
non-identically distributed Bernoulli random variables.</p>
<p>Import the module and create an instance of the distribution with::</p>
<pre><code>#&gt;&gt;&gt; from poibin import PoiBin
#&gt;&gt;&gt; pb = PoiBin(p)
</code></pre>
<p>Be <code>x</code> a list or NumPy array of different number of successes.
To obtain the:</p>
<ul>
<li>
<p>probability mass function of x, use::</p>
<h1 id="pbpmfx">&gt;&gt;&gt; pb.pmf(x)</h1>
</li>
<li>
<p>cumulative distribution function of x, use::</p>
<h1 id="pbcdfx">&gt;&gt;&gt; pb.cdf(x)</h1>
</li>
<li>
<p>p-values of x, use::</p>
<h1 id="pbpvalx">&gt;&gt;&gt; pb.pval(x)</h1>
</li>
</ul>
<p>The functions are applied component-wise and a NumPy array of the same
length as <code>x</code> is returned.</p>
<p>References:
.. [Hong2013] Yili Hong, On computing the distribution function for the Poisson
binomial distribution,
Computational Statistics &amp; Data Analysis, Volume 59, March 2013,
Pages 41-51, ISSN 0167-9473,
<a href="http://dx.doi.org/10.1016/j.csda.2012.10.006.">http://dx.doi.org/10.1016/j.csda.2012.10.006.</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Tue Mar 29, 2016

Module:
    poibin - Poisson Binomial Distribution

Author:
    Mika Straka

Description:
    Implementation of the Poisson Binomial distribution for the sum of
    independent and not identically distributed random variables as described
    in the reference [Hong2013]_.

    Implemented method:

        * ``pmf``: probability mass function
        * ``cdf``: cumulative distribution function
        * ``pval``: p-value (1 - cdf)

Usage:
    Be ``p`` a list or  NumPy array of success probabilities for ``n``
    non-identically distributed Bernoulli random variables.

    Import the module and create an instance of the distribution with::

        #&gt;&gt;&gt; from poibin import PoiBin
        #&gt;&gt;&gt; pb = PoiBin(p)

    Be ``x`` a list or NumPy array of different number of successes.
    To obtain the:

    * probability mass function of x, use::

        #&gt;&gt;&gt; pb.pmf(x)

    * cumulative distribution function of x, use::

        #&gt;&gt;&gt; pb.cdf(x)

    * p-values of x, use::

        #&gt;&gt;&gt; pb.pval(x)

    The functions are applied component-wise and a NumPy array of the same
    length as ``x`` is returned.

References:
.. [Hong2013] Yili Hong, On computing the distribution function for the Poisson
    binomial distribution,
    Computational Statistics &amp; Data Analysis, Volume 59, March 2013,
    Pages 41-51, ISSN 0167-9473,
    http://dx.doi.org/10.1016/j.csda.2012.10.006.
&#34;&#34;&#34;

import collections
import numpy as np


class PoiBin(object):
    &#34;&#34;&#34;Poisson Binomial distribution for random variables.

    This class implements the Poisson Binomial distribution for Bernoulli
    trials with different success probabilities. The distribution describes
    thus a random variable that is the sum of independent and not identically
    distributed single Bernoulli random variables.

    The class offers methods for calculating the probability mass function, the
    cumulative distribution function, and p-values for right-sided testing.
    &#34;&#34;&#34;

    def __init__(self, probabilities):
        &#34;&#34;&#34;Initialize the class and calculate the ``pmf`` and ``cdf``.

        :param probabilities: sequence of success probabilities :math:`p_i \\in
            [0, 1] \\forall i \\in [0, N]` for :math:`N` independent but not
            identically distributed Bernoulli random variables
        :type probabilities: numpy.array
        &#34;&#34;&#34;
        self.success_probabilities = np.array(probabilities)
        self.number_trials = self.success_probabilities.size
        self.check_input_prob()
        self.omega = 2 * np.pi / (self.number_trials + 1)
        self.pmf_list = self.get_pmf_xi()
        self.cdf_list = self.get_cdf(self.pmf_list)

# ------------------------------------------------------------------------------
# Methods for the Poisson Binomial Distribution
# ------------------------------------------------------------------------------

    def pmf(self, number_successes):
        &#34;&#34;&#34;Calculate the probability mass function ``pmf`` for the input values.

        The ``pmf`` is defined as

        .. math::

            pmf(k) = Pr(X = k), k = 0, 1, ..., n.

        :param number_successes: number of successful trials for which the
            probability mass function is calculated
        :type number_successes: int or list of integers
        &#34;&#34;&#34;
        self.check_rv_input(number_successes)
        return self.pmf_list[number_successes]

    def cdf(self, number_successes):
        &#34;&#34;&#34;Calculate the cumulative distribution function for the input values.

        The cumulative distribution function ``cdf`` for a number ``k`` of
        successes is defined as

        .. math::

            cdf(k) = Pr(X \\leq k), k = 0, 1, ..., n.

        :param number_successes: number of successful trials for which the
            cumulative distribution function is calculated
        :type number_successes: int or list of integers
        &#34;&#34;&#34;
        self.check_rv_input(number_successes)
        return self.cdf_list[number_successes]

    def pval(self, number_successes):
        &#34;&#34;&#34;Return the p-values corresponding to the input numbers of successes.

        The p-values for right-sided testing are defined as

        .. math::

            pval(k) = Pr(X \\geq k ),  k = 0, 1, ..., n.

        .. note::

            Since :math:`cdf(k) = Pr(X &lt;= k)`, the function returns

            .. math::

                1 - cdf(X &lt; k) &amp; = 1 - cdf(X &lt;= k - 1)
                               &amp; = 1 - cdf(X &lt;= k) + pmf(X = k),

                               k = 0, 1, .., n.

        :param number_successes: number of successful trials for which the
            p-value is calculated
        :type number_successes: int, numpy.array, or list of integers
        &#34;&#34;&#34;
        self.check_rv_input(number_successes)
        i = 0
        try:
            isinstance(number_successes, collections.Iterable)
            pvalues = np.array(number_successes, dtype=&#39;float&#39;)
            # if input is iterable (list, numpy.array):
            for k in number_successes:
                pvalues[i] = 1. - self.cdf(k) + self.pmf(k)
                i += 1
            return pvalues
        except TypeError:
            # if input is an integer:
            if number_successes == 0:
                return 1
            else:
                return 1 - self.cdf(number_successes - 1)

# ------------------------------------------------------------------------------
# Methods to obtain pmf and cdf
# ------------------------------------------------------------------------------

    def get_cdf(self, event_probabilities):
        &#34;&#34;&#34;Return the values of the cumulative density function.

        Return a list which contains all the values of the cumulative
        density function for :math:`i = 0, 1, ..., n`.

        :param event_probabilities: array of single event probabilities
        :type event_probabilities: numpy.array
        &#34;&#34;&#34;
        cdf = np.empty(self.number_trials + 1)
        cdf[0] = event_probabilities[0]
        for i in range(1, self.number_trials + 1):
            cdf[i] = cdf[i - 1] + event_probabilities[i]
        return cdf

    def get_pmf_xi(self):
        &#34;&#34;&#34;Return the values of the variable ``xi``.

        The components ``xi`` make up the probability mass function, i.e.
        :math:`\\xi(k) = pmf(k) = Pr(X = k)`.
        &#34;&#34;&#34;
        chi = np.empty(self.number_trials + 1, dtype=complex)
        chi[0] = 1
        half_number_trials = int(
            self.number_trials / 2 + self.number_trials % 2)
        # set first half of chis:
        chi[1:half_number_trials + 1] = self.get_chi(
            np.arange(1, half_number_trials + 1))
        # set second half of chis:
        chi[half_number_trials + 1:self.number_trials + 1] = np.conjugate(
            chi[1:self.number_trials - half_number_trials + 1] [::-1])
        chi /= self.number_trials + 1
        xi = np.fft.fft(chi)
        if self.check_xi_are_real(xi):
            xi = xi.real
        else:
            raise TypeError(&#34;pmf / xi values have to be real.&#34;)
        xi += np.finfo(type(xi[0])).eps
        return xi

    def get_chi(self, idx_array):
        &#34;&#34;&#34;Return the values of ``chi`` for the specified indices.

        :param idx_array: array of indices for which the ``chi`` values should
            be calculated
        :type idx_array: numpy.array
        &#34;&#34;&#34;
        # get_z:
        exp_value = np.exp(self.omega * idx_array * 1j)
        xy = 1 - self.success_probabilities + \
            self.success_probabilities * exp_value[:, np.newaxis]
        # sum over the principal values of the arguments of z:
        argz_sum = np.arctan2(xy.imag, xy.real).sum(axis=1)
        # get d value:
        exparg = np.log(np.abs(xy)).sum(axis=1)
        d_value = np.exp(exparg)
        # get chi values:
        chi = d_value * np.exp(argz_sum * 1j)
        return chi

# ------------------------------------------------------------------------------
# Auxiliary functions
# ------------------------------------------------------------------------------

    def check_rv_input(self, number_successes):
        &#34;&#34;&#34;Assert that the input values ``number_successes`` are OK.

        The input values ``number_successes`` for the random variable have to be
        integers, greater or equal to 0, and smaller or equal to the total
        number of trials ``self.number_trials``.

        :param number_successes: number of successful trials
        :type number_successes: int or list of integers &#34;&#34;&#34;
        try:
            for k in number_successes:
                assert (type(k) == int or type(k) == np.int64), \
                        &#34;Values in input list must be integers&#34;
                assert k &gt;= 0, &#39;Values in input list cannot be negative.&#39;
                assert k &lt;= self.number_trials, \
                    &#39;Values in input list must be smaller or equal to the &#39; \
                    &#39;number of input probabilities &#34;n&#34;&#39;
        except TypeError:
            assert (type(number_successes) == int or \
                type(number_successes) == np.int64), \
                &#39;Input value must be an integer.&#39;
            assert number_successes &gt;= 0, &#34;Input value cannot be negative.&#34;
            assert number_successes &lt;= self.number_trials, \
                &#39;Input value cannot be greater than &#39; + str(self.number_trials)
        return True

    @staticmethod
    def check_xi_are_real(xi_values):
        &#34;&#34;&#34;Check whether all the ``xi``s have imaginary part equal to 0.

        The probabilities :math:`\\xi(k) = pmf(k) = Pr(X = k)` have to be
        positive and must have imaginary part equal to zero.

        :param xi_values: single event probabilities
        :type xi_values: complex
        &#34;&#34;&#34;
        check_status = np.all(xi_values.imag &lt;= np.finfo(float).eps*3)
        #print(&#34;imaginary part:&#34;, xi_values.imag)
        #print(&#39;threshold allowed:&#39;, np.finfo(float).eps)
        #print(&#39;pass:&#39;, check_status)
        return check_status

    def check_input_prob(self):
        &#34;&#34;&#34;Check that all the input probabilities are in the interval [0, 1].&#34;&#34;&#34;
        if self.success_probabilities.shape != (self.number_trials,):
            raise ValueError(
                &#34;Input must be an one-dimensional array or a list.&#34;)
        if not np.all(self.success_probabilities &gt;= 0):
            raise ValueError(&#34;Input probabilities have to be non negative.&#34;)


        #if not np.all(self.success_probabilities &lt;= 1.0):
        #    print(self.success_probabilities)
        #    print(self.success_probabilities &lt;= 1.0)
        #    raise ValueError(&#34;Input probabilities have to be smaller than 1.&#34;)

################################################################################
# Main
################################################################################

if __name__ == &#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin"><code class="flex name class">
<span>class <span class="ident">PoiBin</span></span>
<span>(</span><span>probabilities)</span>
</code></dt>
<dd>
<div class="desc"><p>Poisson Binomial distribution for random variables.</p>
<p>This class implements the Poisson Binomial distribution for Bernoulli
trials with different success probabilities. The distribution describes
thus a random variable that is the sum of independent and not identically
distributed single Bernoulli random variables.</p>
<p>The class offers methods for calculating the probability mass function, the
cumulative distribution function, and p-values for right-sided testing.</p>
<p>Initialize the class and calculate the <code>pmf</code> and <code>cdf</code>.</p>
<p>:param probabilities: sequence of success probabilities :math:<code>p_i \in
[0, 1] \forall i \in [0, N]</code> for :math:<code>N</code> independent but not
identically distributed Bernoulli random variables
:type probabilities: numpy.array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PoiBin(object):
    &#34;&#34;&#34;Poisson Binomial distribution for random variables.

    This class implements the Poisson Binomial distribution for Bernoulli
    trials with different success probabilities. The distribution describes
    thus a random variable that is the sum of independent and not identically
    distributed single Bernoulli random variables.

    The class offers methods for calculating the probability mass function, the
    cumulative distribution function, and p-values for right-sided testing.
    &#34;&#34;&#34;

    def __init__(self, probabilities):
        &#34;&#34;&#34;Initialize the class and calculate the ``pmf`` and ``cdf``.

        :param probabilities: sequence of success probabilities :math:`p_i \\in
            [0, 1] \\forall i \\in [0, N]` for :math:`N` independent but not
            identically distributed Bernoulli random variables
        :type probabilities: numpy.array
        &#34;&#34;&#34;
        self.success_probabilities = np.array(probabilities)
        self.number_trials = self.success_probabilities.size
        self.check_input_prob()
        self.omega = 2 * np.pi / (self.number_trials + 1)
        self.pmf_list = self.get_pmf_xi()
        self.cdf_list = self.get_cdf(self.pmf_list)

# ------------------------------------------------------------------------------
# Methods for the Poisson Binomial Distribution
# ------------------------------------------------------------------------------

    def pmf(self, number_successes):
        &#34;&#34;&#34;Calculate the probability mass function ``pmf`` for the input values.

        The ``pmf`` is defined as

        .. math::

            pmf(k) = Pr(X = k), k = 0, 1, ..., n.

        :param number_successes: number of successful trials for which the
            probability mass function is calculated
        :type number_successes: int or list of integers
        &#34;&#34;&#34;
        self.check_rv_input(number_successes)
        return self.pmf_list[number_successes]

    def cdf(self, number_successes):
        &#34;&#34;&#34;Calculate the cumulative distribution function for the input values.

        The cumulative distribution function ``cdf`` for a number ``k`` of
        successes is defined as

        .. math::

            cdf(k) = Pr(X \\leq k), k = 0, 1, ..., n.

        :param number_successes: number of successful trials for which the
            cumulative distribution function is calculated
        :type number_successes: int or list of integers
        &#34;&#34;&#34;
        self.check_rv_input(number_successes)
        return self.cdf_list[number_successes]

    def pval(self, number_successes):
        &#34;&#34;&#34;Return the p-values corresponding to the input numbers of successes.

        The p-values for right-sided testing are defined as

        .. math::

            pval(k) = Pr(X \\geq k ),  k = 0, 1, ..., n.

        .. note::

            Since :math:`cdf(k) = Pr(X &lt;= k)`, the function returns

            .. math::

                1 - cdf(X &lt; k) &amp; = 1 - cdf(X &lt;= k - 1)
                               &amp; = 1 - cdf(X &lt;= k) + pmf(X = k),

                               k = 0, 1, .., n.

        :param number_successes: number of successful trials for which the
            p-value is calculated
        :type number_successes: int, numpy.array, or list of integers
        &#34;&#34;&#34;
        self.check_rv_input(number_successes)
        i = 0
        try:
            isinstance(number_successes, collections.Iterable)
            pvalues = np.array(number_successes, dtype=&#39;float&#39;)
            # if input is iterable (list, numpy.array):
            for k in number_successes:
                pvalues[i] = 1. - self.cdf(k) + self.pmf(k)
                i += 1
            return pvalues
        except TypeError:
            # if input is an integer:
            if number_successes == 0:
                return 1
            else:
                return 1 - self.cdf(number_successes - 1)

# ------------------------------------------------------------------------------
# Methods to obtain pmf and cdf
# ------------------------------------------------------------------------------

    def get_cdf(self, event_probabilities):
        &#34;&#34;&#34;Return the values of the cumulative density function.

        Return a list which contains all the values of the cumulative
        density function for :math:`i = 0, 1, ..., n`.

        :param event_probabilities: array of single event probabilities
        :type event_probabilities: numpy.array
        &#34;&#34;&#34;
        cdf = np.empty(self.number_trials + 1)
        cdf[0] = event_probabilities[0]
        for i in range(1, self.number_trials + 1):
            cdf[i] = cdf[i - 1] + event_probabilities[i]
        return cdf

    def get_pmf_xi(self):
        &#34;&#34;&#34;Return the values of the variable ``xi``.

        The components ``xi`` make up the probability mass function, i.e.
        :math:`\\xi(k) = pmf(k) = Pr(X = k)`.
        &#34;&#34;&#34;
        chi = np.empty(self.number_trials + 1, dtype=complex)
        chi[0] = 1
        half_number_trials = int(
            self.number_trials / 2 + self.number_trials % 2)
        # set first half of chis:
        chi[1:half_number_trials + 1] = self.get_chi(
            np.arange(1, half_number_trials + 1))
        # set second half of chis:
        chi[half_number_trials + 1:self.number_trials + 1] = np.conjugate(
            chi[1:self.number_trials - half_number_trials + 1] [::-1])
        chi /= self.number_trials + 1
        xi = np.fft.fft(chi)
        if self.check_xi_are_real(xi):
            xi = xi.real
        else:
            raise TypeError(&#34;pmf / xi values have to be real.&#34;)
        xi += np.finfo(type(xi[0])).eps
        return xi

    def get_chi(self, idx_array):
        &#34;&#34;&#34;Return the values of ``chi`` for the specified indices.

        :param idx_array: array of indices for which the ``chi`` values should
            be calculated
        :type idx_array: numpy.array
        &#34;&#34;&#34;
        # get_z:
        exp_value = np.exp(self.omega * idx_array * 1j)
        xy = 1 - self.success_probabilities + \
            self.success_probabilities * exp_value[:, np.newaxis]
        # sum over the principal values of the arguments of z:
        argz_sum = np.arctan2(xy.imag, xy.real).sum(axis=1)
        # get d value:
        exparg = np.log(np.abs(xy)).sum(axis=1)
        d_value = np.exp(exparg)
        # get chi values:
        chi = d_value * np.exp(argz_sum * 1j)
        return chi

# ------------------------------------------------------------------------------
# Auxiliary functions
# ------------------------------------------------------------------------------

    def check_rv_input(self, number_successes):
        &#34;&#34;&#34;Assert that the input values ``number_successes`` are OK.

        The input values ``number_successes`` for the random variable have to be
        integers, greater or equal to 0, and smaller or equal to the total
        number of trials ``self.number_trials``.

        :param number_successes: number of successful trials
        :type number_successes: int or list of integers &#34;&#34;&#34;
        try:
            for k in number_successes:
                assert (type(k) == int or type(k) == np.int64), \
                        &#34;Values in input list must be integers&#34;
                assert k &gt;= 0, &#39;Values in input list cannot be negative.&#39;
                assert k &lt;= self.number_trials, \
                    &#39;Values in input list must be smaller or equal to the &#39; \
                    &#39;number of input probabilities &#34;n&#34;&#39;
        except TypeError:
            assert (type(number_successes) == int or \
                type(number_successes) == np.int64), \
                &#39;Input value must be an integer.&#39;
            assert number_successes &gt;= 0, &#34;Input value cannot be negative.&#34;
            assert number_successes &lt;= self.number_trials, \
                &#39;Input value cannot be greater than &#39; + str(self.number_trials)
        return True

    @staticmethod
    def check_xi_are_real(xi_values):
        &#34;&#34;&#34;Check whether all the ``xi``s have imaginary part equal to 0.

        The probabilities :math:`\\xi(k) = pmf(k) = Pr(X = k)` have to be
        positive and must have imaginary part equal to zero.

        :param xi_values: single event probabilities
        :type xi_values: complex
        &#34;&#34;&#34;
        check_status = np.all(xi_values.imag &lt;= np.finfo(float).eps*3)
        #print(&#34;imaginary part:&#34;, xi_values.imag)
        #print(&#39;threshold allowed:&#39;, np.finfo(float).eps)
        #print(&#39;pass:&#39;, check_status)
        return check_status

    def check_input_prob(self):
        &#34;&#34;&#34;Check that all the input probabilities are in the interval [0, 1].&#34;&#34;&#34;
        if self.success_probabilities.shape != (self.number_trials,):
            raise ValueError(
                &#34;Input must be an one-dimensional array or a list.&#34;)
        if not np.all(self.success_probabilities &gt;= 0):
            raise ValueError(&#34;Input probabilities have to be non negative.&#34;)


        #if not np.all(self.success_probabilities &lt;= 1.0):
        #    print(self.success_probabilities)
        #    print(self.success_probabilities &lt;= 1.0)
        #    raise ValueError(&#34;Input probabilities have to be smaller than 1.&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.check_xi_are_real"><code class="name flex">
<span>def <span class="ident">check_xi_are_real</span></span>(<span>xi_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether all the <code>xi</code>s have imaginary part equal to 0.</p>
<p>The probabilities :math:<code>\xi(k) = pmf(k) = Pr(X = k)</code> have to be
positive and must have imaginary part equal to zero.</p>
<p>:param xi_values: single event probabilities
:type xi_values: complex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def check_xi_are_real(xi_values):
    &#34;&#34;&#34;Check whether all the ``xi``s have imaginary part equal to 0.

    The probabilities :math:`\\xi(k) = pmf(k) = Pr(X = k)` have to be
    positive and must have imaginary part equal to zero.

    :param xi_values: single event probabilities
    :type xi_values: complex
    &#34;&#34;&#34;
    check_status = np.all(xi_values.imag &lt;= np.finfo(float).eps*3)
    #print(&#34;imaginary part:&#34;, xi_values.imag)
    #print(&#39;threshold allowed:&#39;, np.finfo(float).eps)
    #print(&#39;pass:&#39;, check_status)
    return check_status</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, number_successes)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the cumulative distribution function for the input values.</p>
<p>The cumulative distribution function <code>cdf</code> for a number <code>k</code> of
successes is defined as</p>
<p>[ cdf(k) = Pr(X \leq k), k = 0, 1, &hellip;, n. ]
:param number_successes: number of successful trials for which the
cumulative distribution function is calculated
:type number_successes: int or list of integers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self, number_successes):
    &#34;&#34;&#34;Calculate the cumulative distribution function for the input values.

    The cumulative distribution function ``cdf`` for a number ``k`` of
    successes is defined as

    .. math::

        cdf(k) = Pr(X \\leq k), k = 0, 1, ..., n.

    :param number_successes: number of successful trials for which the
        cumulative distribution function is calculated
    :type number_successes: int or list of integers
    &#34;&#34;&#34;
    self.check_rv_input(number_successes)
    return self.cdf_list[number_successes]</code></pre>
</details>
</dd>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.check_input_prob"><code class="name flex">
<span>def <span class="ident">check_input_prob</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check that all the input probabilities are in the interval [0, 1].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_input_prob(self):
    &#34;&#34;&#34;Check that all the input probabilities are in the interval [0, 1].&#34;&#34;&#34;
    if self.success_probabilities.shape != (self.number_trials,):
        raise ValueError(
            &#34;Input must be an one-dimensional array or a list.&#34;)
    if not np.all(self.success_probabilities &gt;= 0):
        raise ValueError(&#34;Input probabilities have to be non negative.&#34;)


    #if not np.all(self.success_probabilities &lt;= 1.0):
    #    print(self.success_probabilities)
    #    print(self.success_probabilities &lt;= 1.0)
    #    raise ValueError(&#34;Input probabilities have to be smaller than 1.&#34;)</code></pre>
</details>
</dd>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.check_rv_input"><code class="name flex">
<span>def <span class="ident">check_rv_input</span></span>(<span>self, number_successes)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that the input values <code>number_successes</code> are OK.</p>
<p>The input values <code>number_successes</code> for the random variable have to be
integers, greater or equal to 0, and smaller or equal to the total
number of trials <code>self.number_trials</code>.</p>
<p>:param number_successes: number of successful trials
:type number_successes: int or list of integers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_rv_input(self, number_successes):
    &#34;&#34;&#34;Assert that the input values ``number_successes`` are OK.

    The input values ``number_successes`` for the random variable have to be
    integers, greater or equal to 0, and smaller or equal to the total
    number of trials ``self.number_trials``.

    :param number_successes: number of successful trials
    :type number_successes: int or list of integers &#34;&#34;&#34;
    try:
        for k in number_successes:
            assert (type(k) == int or type(k) == np.int64), \
                    &#34;Values in input list must be integers&#34;
            assert k &gt;= 0, &#39;Values in input list cannot be negative.&#39;
            assert k &lt;= self.number_trials, \
                &#39;Values in input list must be smaller or equal to the &#39; \
                &#39;number of input probabilities &#34;n&#34;&#39;
    except TypeError:
        assert (type(number_successes) == int or \
            type(number_successes) == np.int64), \
            &#39;Input value must be an integer.&#39;
        assert number_successes &gt;= 0, &#34;Input value cannot be negative.&#34;
        assert number_successes &lt;= self.number_trials, \
            &#39;Input value cannot be greater than &#39; + str(self.number_trials)
    return True</code></pre>
</details>
</dd>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.get_cdf"><code class="name flex">
<span>def <span class="ident">get_cdf</span></span>(<span>self, event_probabilities)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the values of the cumulative density function.</p>
<p>Return a list which contains all the values of the cumulative
density function for :math:<code>i = 0, 1, ..., n</code>.</p>
<p>:param event_probabilities: array of single event probabilities
:type event_probabilities: numpy.array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cdf(self, event_probabilities):
    &#34;&#34;&#34;Return the values of the cumulative density function.

    Return a list which contains all the values of the cumulative
    density function for :math:`i = 0, 1, ..., n`.

    :param event_probabilities: array of single event probabilities
    :type event_probabilities: numpy.array
    &#34;&#34;&#34;
    cdf = np.empty(self.number_trials + 1)
    cdf[0] = event_probabilities[0]
    for i in range(1, self.number_trials + 1):
        cdf[i] = cdf[i - 1] + event_probabilities[i]
    return cdf</code></pre>
</details>
</dd>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.get_chi"><code class="name flex">
<span>def <span class="ident">get_chi</span></span>(<span>self, idx_array)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the values of <code>chi</code> for the specified indices.</p>
<p>:param idx_array: array of indices for which the <code>chi</code> values should
be calculated
:type idx_array: numpy.array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chi(self, idx_array):
    &#34;&#34;&#34;Return the values of ``chi`` for the specified indices.

    :param idx_array: array of indices for which the ``chi`` values should
        be calculated
    :type idx_array: numpy.array
    &#34;&#34;&#34;
    # get_z:
    exp_value = np.exp(self.omega * idx_array * 1j)
    xy = 1 - self.success_probabilities + \
        self.success_probabilities * exp_value[:, np.newaxis]
    # sum over the principal values of the arguments of z:
    argz_sum = np.arctan2(xy.imag, xy.real).sum(axis=1)
    # get d value:
    exparg = np.log(np.abs(xy)).sum(axis=1)
    d_value = np.exp(exparg)
    # get chi values:
    chi = d_value * np.exp(argz_sum * 1j)
    return chi</code></pre>
</details>
</dd>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.get_pmf_xi"><code class="name flex">
<span>def <span class="ident">get_pmf_xi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the values of the variable <code>xi</code>.</p>
<p>The components <code>xi</code> make up the probability mass function, i.e.
:math:<code>\xi(k) = pmf(k) = Pr(X = k)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pmf_xi(self):
    &#34;&#34;&#34;Return the values of the variable ``xi``.

    The components ``xi`` make up the probability mass function, i.e.
    :math:`\\xi(k) = pmf(k) = Pr(X = k)`.
    &#34;&#34;&#34;
    chi = np.empty(self.number_trials + 1, dtype=complex)
    chi[0] = 1
    half_number_trials = int(
        self.number_trials / 2 + self.number_trials % 2)
    # set first half of chis:
    chi[1:half_number_trials + 1] = self.get_chi(
        np.arange(1, half_number_trials + 1))
    # set second half of chis:
    chi[half_number_trials + 1:self.number_trials + 1] = np.conjugate(
        chi[1:self.number_trials - half_number_trials + 1] [::-1])
    chi /= self.number_trials + 1
    xi = np.fft.fft(chi)
    if self.check_xi_are_real(xi):
        xi = xi.real
    else:
        raise TypeError(&#34;pmf / xi values have to be real.&#34;)
    xi += np.finfo(type(xi[0])).eps
    return xi</code></pre>
</details>
</dd>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.pmf"><code class="name flex">
<span>def <span class="ident">pmf</span></span>(<span>self, number_successes)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the probability mass function <code>pmf</code> for the input values.</p>
<p>The <code>pmf</code> is defined as</p>
<p>[ pmf(k) = Pr(X = k), k = 0, 1, &hellip;, n. ]
:param number_successes: number of successful trials for which the
probability mass function is calculated
:type number_successes: int or list of integers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pmf(self, number_successes):
    &#34;&#34;&#34;Calculate the probability mass function ``pmf`` for the input values.

    The ``pmf`` is defined as

    .. math::

        pmf(k) = Pr(X = k), k = 0, 1, ..., n.

    :param number_successes: number of successful trials for which the
        probability mass function is calculated
    :type number_successes: int or list of integers
    &#34;&#34;&#34;
    self.check_rv_input(number_successes)
    return self.pmf_list[number_successes]</code></pre>
</details>
</dd>
<dt id="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.pval"><code class="name flex">
<span>def <span class="ident">pval</span></span>(<span>self, number_successes)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the p-values corresponding to the input numbers of successes.</p>
<p>The p-values for right-sided testing are defined as</p>
<p>[ pval(k) = Pr(X \geq k ),
k = 0, 1, &hellip;, n. ]</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since :math:<code>cdf(k) = Pr(X &lt;= k)</code>, the function returns</p>
<p>[ 1 - cdf(X &lt; k) &amp; = 1 - cdf(X &lt;= k - 1)
&amp; = 1 - cdf(X &lt;= k) + pmf(X = k),</p>
<p>k = 0, 1, .., n. ]</p>
</div>
<p>:param number_successes: number of successful trials for which the
p-value is calculated
:type number_successes: int, numpy.array, or list of integers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pval(self, number_successes):
    &#34;&#34;&#34;Return the p-values corresponding to the input numbers of successes.

    The p-values for right-sided testing are defined as

    .. math::

        pval(k) = Pr(X \\geq k ),  k = 0, 1, ..., n.

    .. note::

        Since :math:`cdf(k) = Pr(X &lt;= k)`, the function returns

        .. math::

            1 - cdf(X &lt; k) &amp; = 1 - cdf(X &lt;= k - 1)
                           &amp; = 1 - cdf(X &lt;= k) + pmf(X = k),

                           k = 0, 1, .., n.

    :param number_successes: number of successful trials for which the
        p-value is calculated
    :type number_successes: int, numpy.array, or list of integers
    &#34;&#34;&#34;
    self.check_rv_input(number_successes)
    i = 0
    try:
        isinstance(number_successes, collections.Iterable)
        pvalues = np.array(number_successes, dtype=&#39;float&#39;)
        # if input is iterable (list, numpy.array):
        for k in number_successes:
            pvalues[i] = 1. - self.cdf(k) + self.pmf(k)
            i += 1
        return pvalues
    except TypeError:
        # if input is an integer:
        if number_successes == 0:
            return 1
        else:
            return 1 - self.cdf(number_successes - 1)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="divAtScale.src.bipartite_config.src.poibin" href="index.html">divAtScale.src.bipartite_config.src.poibin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin">PoiBin</a></code></h4>
<ul class="two-column">
<li><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.cdf" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.cdf">cdf</a></code></li>
<li><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.check_input_prob" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.check_input_prob">check_input_prob</a></code></li>
<li><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.check_rv_input" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.check_rv_input">check_rv_input</a></code></li>
<li><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.check_xi_are_real" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.check_xi_are_real">check_xi_are_real</a></code></li>
<li><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.get_cdf" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.get_cdf">get_cdf</a></code></li>
<li><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.get_chi" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.get_chi">get_chi</a></code></li>
<li><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.get_pmf_xi" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.get_pmf_xi">get_pmf_xi</a></code></li>
<li><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.pmf" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.pmf">pmf</a></code></li>
<li><code><a title="divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.pval" href="#divAtScale.src.bipartite_config.src.poibin.poibin.PoiBin.pval">pval</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>